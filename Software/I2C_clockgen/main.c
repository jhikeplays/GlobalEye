#include <stdint.h>
#include <stdbool.h>
#include "ti_msp_dl_config.h"   // generated by SysConfig


// =========================
// I2C protocol (16-bit ticks)
// =========================
enum {
    CMD_SET_FRAME = 0x10, // payload: u16 LE
    CMD_SET_EXPO  = 0x11, // payload: u16 LE
    CMD_SET_BOTH  = 0x12, // payload: u16 LE frame, then u16 LE expo
};

// These are now *timer ticks* (already computed on the controller side)
static volatile uint16_t g_frame_ticks = TIMER_FRM_INST_LOAD_VALUE; // example default
static volatile uint16_t g_expo_ticks  = TIMER_EXP_INST_LOAD_VALUE;  // example default
static volatile bool     g_all_update_pending = false;
static volatile bool     g_frm_update_pending = false;
static volatile bool     g_exp_update_pending = false;

// RX state
static volatile uint8_t  s_cmd  = 0;
static volatile uint8_t  s_need = 0, s_idx = 0;
static volatile uint8_t  s_buf[4];

// =========================
// Helpers
// =========================
static inline uint16_t le_u16(const volatile uint8_t *p)
{
    return (uint16_t)p[0] | ((uint16_t)p[1] << 8);
}

static void timers_apply_ticks(uint16_t frame_ticks, uint16_t expo_ticks)
{
    // Update Frame timer (TIM0): periodic
    DL_Timer_stopCounter(TIMER_FRM_INST);                             // :contentReference[oaicite:2]{index=2}
    DL_Timer_setLoadValue(TIMER_FRM_INST, (uint32_t)frame_ticks);     // :contentReference[oaicite:3]{index=3}
    DL_Timer_startCounter(TIMER_FRM_INST);                            // :contentReference[oaicite:5]{index=5}

    // Update Exposure timer (TIMG14): one-shot, started each frame
    DL_Timer_stopCounter(TIMER_EXP_INST);
    DL_Timer_setLoadValue(TIMER_EXP_INST, (uint32_t)expo_ticks);

    g_frame_ticks = frame_ticks;
    g_expo_ticks  = expo_ticks;
}

static void timers_apply_expticks(uint16_t expo_ticks)
{
    // Update Exposure timer (TIMG14): one-shot, started each frame
    DL_Timer_stopCounter(TIMER_EXP_INST);
    DL_Timer_setLoadValue(TIMER_EXP_INST, (uint32_t)expo_ticks);
    g_expo_ticks  = expo_ticks;
}

static void timers_apply_frameticks(uint16_t frame_ticks)
{
    // Update Frame timer (TIM0): periodic
    DL_Timer_stopCounter(TIMER_FRM_INST);                             // :contentReference[oaicite:2]{index=2}
    DL_Timer_setLoadValue(TIMER_FRM_INST, (uint32_t)frame_ticks);     // :contentReference[oaicite:3]{index=3}
    DL_Timer_startCounter(TIMER_FRM_INST);    
    g_frame_ticks = frame_ticks;
}

// =========================
// I2C receive helper (16-bit payloads)
// =========================
static void i2c_rx_byte(uint8_t b)
{
    if (s_need == 0) {
        // expecting command
        s_cmd = b;
        s_idx = 0;

        if (s_cmd == CMD_SET_FRAME || s_cmd == CMD_SET_EXPO) {
            s_need = 2;
        } else if (s_cmd == CMD_SET_BOTH) {
            s_need = 4;
        } else {
            s_cmd  = 0;
            s_need = 0;
        }
        return;
    }

    // receiving payload
    if (s_idx < sizeof(s_buf)) {
        s_buf[s_idx] = b;
    }
    s_idx++;

    if (s_idx >= s_need) {
        if (s_cmd == CMD_SET_FRAME && s_need == 2) {
            uint16_t v = le_u16(&s_buf[0]);
            g_frame_ticks = v;
            g_frm_update_pending = true;

        } else if (s_cmd == CMD_SET_EXPO && s_need == 2) {
            uint16_t v = le_u16(&s_buf[0]);
            g_expo_ticks = v;
            g_exp_update_pending = true;

        } else if (s_cmd == CMD_SET_BOTH && s_need == 4) {
            uint16_t vf = le_u16(&s_buf[0]);
            uint16_t ve = le_u16(&s_buf[2]);
            g_frame_ticks = vf;
            g_expo_ticks  = ve;
            g_all_update_pending = true;
        }

        // reset state
        s_cmd  = 0;
        s_need = 0;
        s_idx  = 0;
    }
}

// =========================
// ISRs
// =========================
// Frame timer: rising edge + start exposure timer
void TIMER_FRM_INST_IRQHandler(void)
{
    DL_GPIO_setPins(TEXP_PORT, TEXP_TEXP1_PIN);
}

// Exposure timer: falling edge
void TIMER_EXP_INST_IRQHandler(void)
{
    DL_GPIO_clearPins(TEXP_PORT, TEXP_TEXP1_PIN);
}

uint8_t i2c_rtw = 0x12;
// I2C target ISR: adapt to your instance name (I2C_INST) per your existing example
void I2C_INST_IRQHandler(void)
{
    switch (DL_I2C_getPendingInterrupt(I2C_INST)) {
        case DL_I2C_IIDX_TARGET_START:
            DL_I2C_fillTargetTXFIFO(I2C_INST,&i2c_rtw , 1);
            /* Optional: preload TX FIFO for reads if your controller reads back regs */
            break;
        case DL_I2C_IIDX_TARGET_RXFIFO_TRIGGER:
            while (DL_I2C_isTargetRXFIFOEmpty(I2C_INST) == false) {
                i2c_rx_byte(DL_I2C_receiveTargetData(I2C_INST));
            }
            break;
        case DL_I2C_IIDX_TARGET_STOP:
            // reset partial packet on STOP
            s_need = 0; s_idx = 0; s_cmd = 0;
            DL_I2C_flushTargetRXFIFO(I2C_INST);
            break;
        default:
            break;
    }
}

// =========================
// main
// =========================
int main(void)
{
    SYSCFG_DL_init(); 

    // Enable IRQs
    NVIC_EnableIRQ(TIMER_FRM_INST_INT_IRQN);
    NVIC_EnableIRQ(TIMER_EXP_INST_INT_IRQN);
    NVIC_EnableIRQ(I2C_INST_INT_IRQN);

    DL_TimerA_startCounter(TIMER_FRM_INST);

    while (1) {
        if (g_all_update_pending) {
            // Snapshot then apply (minimize time in inconsistent state)
            uint16_t ft = g_frame_ticks;
            uint16_t et = g_expo_ticks;
            g_all_update_pending = false;
            timers_apply_ticks(ft, et);
        }
        if (g_exp_update_pending) {
            uint16_t et = g_expo_ticks;
            g_exp_update_pending = false;
            timers_apply_expticks(et);
        }
        if (g_frm_update_pending) {
            uint16_t ft = g_frame_ticks;
            g_frm_update_pending = false;
            timers_apply_frameticks(ft);
        }
        __WFI();
    }
}
